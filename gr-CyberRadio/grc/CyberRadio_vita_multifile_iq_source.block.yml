# auto-generated by grc.converter

id: CyberRadio_vita_multifile_iq_source
label: '[CyberRadio] VITA Multi-File I/Q Source'
category: '[CyberRadio]/Vita and UDP Sources'

parameters:
-   id: filespecs
    label: File Name/Specification List
    dtype: raw
    default: '[]'
-   id: alphabetical
    label: Process Files Alphabetically
    dtype: bool
    default: 'True'
-   id: vita_type
    label: VITA Type
    dtype: int
    default: '0'
    hide: part
-   id: payload_size
    label: VITA Payload Size
    dtype: int
    default: '8192'
    hide: part
-   id: vita_header_size
    label: VITA Header Size
    dtype: int
    default: '0'
    hide: part
-   id: vita_tail_size
    label: VITA Tail Size
    dtype: int
    default: '0'
    hide: part
-   id: byte_swapped
    label: Byte-Swapped
    dtype: bool
    default: 'False'
    hide: part
-   id: iq_swapped
    label: I/Q Swapped
    dtype: bool
    default: 'False'
    hide: part
-   id: iq_scale_factor
    label: I/Q Scale Factor
    dtype: float
    default: '1.0'
    hide: part
-   id: repeat
    label: Repeat
    dtype: bool
    default: 'False'
-   id: terminate_at_end
    label: Terminate When Data Ends
    dtype: bool
    default: 'False'
-   id: tagged
    label: Tagged Output Streams
    dtype: bool
    default: 'False'
-   id: debug
    label: Debug Mode
    dtype: bool
    default: 'False'

outputs:
-   domain: stream
    dtype: complex
    vlen: 1
    optional: true

templates:
    imports: import CyberRadio
    make: |-
        CyberRadio.vita_multifile_iq_source(
          filespecs=${filespecs},
          alphabetical=${alphabetical},
          vita_type=${vita_type},
          payload_size=${payload_size},
          vita_header_size=${vita_header_size},
          vita_tail_size=${vita_tail_size},
          byte_swapped=${byte_swapped},
          iq_swapped=${iq_swapped},
          iq_scale_factor=${iq_scale_factor},
          repeat=${repeat},
          terminate_at_end=${terminate_at_end},
          tagged=${tagged},
          debug=${debug},
        )
    callbacks:
    - open(${filespecs}, ${alphabetical}, ${repeat})
    - set_iq_scale_factor(${iq_scale_factor})

documentation: |-
    Generic VITA 49-compatible I/Q data source block that pulls its source data from a sequence of files.

    The vita_multifile_iq_source block provides I/Q data from a sequence of files on disk.  The sequence of files can be explicitly provided by the user, determined by evaluating a wildcard file specification, or some combination of these.

    The behavior of this block when it has no active files to read data from depends on the Terminate When Data Ends option.  If this option is True, then the flowgraph will terminate.  If it is not set, then it will output (complex) zeros until it does have valid data files.

    This block assumes that the data being read from disk is in a format returned by an NDR-class radio.  This will be either raw I/Q data (16-bit interleaved I and Q) or VITA 49 frame format.  The output from this block is native (32-bit) complex.

    The vita_multifile_iq_source block can also produce stream tags at the beginning of each received VITA 49 frame.  The block generates the following stream tags, as appropriate for the radio:
    * absolute_sample_num -- The absolute sample number
    * absolute_packet_num -- The absolute packet number
    * filename -- The file name that the data comes from.  If the packet spans files, the file name will be the file that the beginning of the packet data came from.
    * frame_counter -- The VITA frame counter
    * frame_size -- The VITA frame size
    * packet_type -- The VITA packet type
    * packet_counter -- The VITA packet counter
    * packet_size -- The VITA packet size
    * stream_id -- The VITA stream ID
    * timestamp_int_type -- The VITA timestamp integer (TSI) field type
    * timestamp_int -- The VITA timestamp integer (TSI) field
    * timestamp_frac_type -- The VITA timestamp fractional (TSF) field type
    * timestamp_frac -- The VITA timestamp fractional (TSF) field
    * organizationally_unique_id -- The organizationally unique ID (OUI)
    * information_class_code -- The information class code (ICC)
    * packet_class_code -- The packet class code (PCC)

    In addition, this block provides some features that are useful in a GUI environment, where the file(s) that the user wants to use is (are) not necessarily known when the flowgraph starts. (This is a drawback of the stock file_source object in GNU Radio.)

file_format: 1
